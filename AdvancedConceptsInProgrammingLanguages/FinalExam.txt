Final Exam
1. 
	a. Declarative, functional, imperative.
		- Declarative - talking about WHAT something is
		- Functional - defining functions that can be composed together to compute something
		- Imperative - talking about HOW to compute something
		
		- Post grammar - The Post Grammar (or context free grammar) is a computational model based around string manipulation
		and substitution where you have
		terminal symbols, non-terminal symbols (variables), an initial start symbol and a set of production rules. A production rule
		is where you say a symbol can be substituted using another symbol, either terminal or non-terminal. A production rule must be of the
		form X --> Y where X is 1 or many symbols (terminal or non-terminal) and Y is 0 or many symbols (terminal or non-terminal).
		An algorithm in the Post Grammar computational model would be seen as the sets of terminal symbols, non-terminal symbols,
		production rules and the initial start symbol together to compute something. It does not look like a set of steps to perform
		in a particular order like you might see in an imperative algorithm but instead a set of declarations where you define
		each set described above in order to create an algorithm for whatever you are trying to compute.
		
		The post grammar computational
		model can be viewed in the same light as the declarative programming paradigm in that both of these only need to concern themselves
		with talking about WHAT something is, not necessarily HOW to compute anything. The production rules of a Post Grammar can be viewed
		as declaring what a symbol is, or can be substituted with.
		
		- Lambda Calculus - Lambda calculus is another computation model based on the idea of defining functions that are abstracted
		to use variables that can be substituted to make the function very reusable. An algorithm in lamda calculus would be a set of
		functions that are composed together in order to compute something. Recursion is heavily used when implementing functions in this
		computational model. The output of one function would be used as the input of another to build an algorithm that computes something.
		This computational model can be viewed in the same light as the functional programming paradigm, it is the idea that this paradigm
		is based on. In both you define functions with inputs and outputs that are composed together in order to compute something.
		The variables are not bounded until you execute an algorithm with some sort of starting input.
		
		- Turing machine - The Turing machine is another computational model that can be seen as a finite state machine where variables
		are written to and read from and computations are performed and results stored. You move from one state to another in this model
		by executing an instruction. An instruction might be writing a new value to a variable or performing a math operation. This model
		is based heavily on executing a sequence of instructions in a particular order, as defined by the algorithm. An algorithm in this
		model would look like a lot of assignment statements and mathematical computations that are executed in a specific order.
	b. Polog, Lisp/Scheme, Go
		- Prolog - The Prolog programming language was based on the declarative programming paradigm and post grammars. This is
		evident when you view the production rules of a post grammar as the facts and relations written in Prolog. A prolog fact can
		be viewed as providing a set of terminal symbols and a prolog relation can be viewed as a production rule. Writing either of these
		in Prolog is declarative because all you do is say WHAT something is using relations and facts. You do not have to 
		(for the most part) concern yourself with HOW to compute something, aside from some nuances of the Prolog interpreter.
		These can be combined by the Prolog
		interpreter to answer queries about a knowledge base. A knowledge base in Prolog is a set of facts and relations.

		
		- Lisp/Scheme - Based on Lambda calculus. 